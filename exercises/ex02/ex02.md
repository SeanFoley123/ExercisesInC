# Exercise 2
## Pointers

### The address space

1. Compile and run `aspace.c` in this directory.

2. Read the code.  You might want to [read about malloc here](https://www.tutorialspoint.com/c_standard_library/c_function_malloc.htm).

3. Based on the output, draw a sketch of the virtual address space (see page 80 of HFC).  Show the relative locations of the stack, heap, globals, constants, and code.

4. Add a second call to `malloc` and check whether the heap on your system grows up (toward larger addresses).  

5. Add a function that prints the address of a local variable, and check whether the stack grows down.  

6. Choose a random number between 1 and 32, and allocate two chunks with that size.  
How much space is there between them?  Hint: Google knows how to subtract hexadecimal numbers.


### Stack allocated data

1.  Read `stack.c`, which should be in this directory.  What is it
  intended to do?  What would the output be if the program worked as
  expected?
  - It seems like the idea is to initialize an array of all 42s with foo, change it so that the values count from 0 to SIZE-1 using bar, and then print each value out one at a time.
2.  Compile it.  Do you get a warning?  What does it mean?
    - First, we get a warning in foo. The issue seems to be that we're trying to directly return an array of values instead of a pointer to that array.
3.  Run it.  What happens?  You might get a segmentation fault, or you might get
  some strange output.  Can you explain it?  You might find it
  helpful to draw a stack diagram.
  - I just got a segmentation fault.
4.  Comment out the `print` statements in `foo()` and `bar()` and run
  it again.  What happens now?
5.  Add comments to the code to explain these experiments and the results,
  then check the code in to the repo.

Moral: Don't return pointers to stack allocated data!

Notes to self: Compile with -g flag for debug, then run gdb with your compiled program
Before you use there functions, you need to `#include <string.h>`.
